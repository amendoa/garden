/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var files = __webpack_require__(1);

	files.keys().forEach(files);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./components/alert": 2,
		"./components/alert.js": 2,
		"./components/collapse": 7,
		"./components/collapse.js": 7,
		"./components/confirm": 8,
		"./components/confirm.js": 8,
		"./components/form": 9,
		"./components/form.js": 9,
		"./components/lazy-load": 10,
		"./components/lazy-load.js": 10,
		"./components/modal": 4,
		"./components/modal.js": 4,
		"./components/notification": 13,
		"./components/notification.js": 13,
		"./components/scroll": 15,
		"./components/scroll.js": 15,
		"./components/tooltip": 18,
		"./components/tooltip.js": 18,
		"./components/validation": 20,
		"./components/validation.js": 20,
		"./components/validation/confirm": 23,
		"./components/validation/confirm.js": 23,
		"./components/validation/defaults": 21,
		"./components/validation/defaults.js": 21,
		"./components/validation/email": 26,
		"./components/validation/email.js": 26,
		"./components/validation/maxlength": 25,
		"./components/validation/maxlength.js": 25,
		"./components/validation/minlength": 24,
		"./components/validation/minlength.js": 24,
		"./components/validation/required": 22,
		"./components/validation/required.js": 22
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 1;


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Alert = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _jquery = __webpack_require__(3);

	var _jquery2 = _interopRequireDefault(_jquery);

	var _modal = __webpack_require__(4);

	var _modal2 = _interopRequireDefault(_modal);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var NAME = 'alert';

	var DEFAULTS = {
	  textMessage: 'This is an example message',
	  textButton: 'Ok',
	  size: 'medium',
	  triggerClose: '[data-alert-button]'
	};

	var Alert = function () {
	  function Alert() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, Alert);

	    this.options = _jquery2.default.extend({}, DEFAULTS, options);
	  }

	  _createClass(Alert, [{
	    key: 'init',
	    value: function init() {
	      this.setupAlert();
	      this.showAlert();
	    }
	  }, {
	    key: 'setupAlert',
	    value: function setupAlert() {
	      var _options = this.options,
	          textMessage = _options.textMessage,
	          textButton = _options.textButton,
	          size = _options.size,
	          triggerClose = _options.triggerClose;

	      this.$element = (0, _jquery2.default)(this.buildHtml(textMessage, textButton));

	      this.modal = (0, _jquery2.default)(this.$element).modal({ triggerClose: triggerClose, size: size }).data('modal');
	    }
	  }, {
	    key: 'showAlert',
	    value: function showAlert() {
	      var modal = this.modal;
	      var triggerClose = this.options.triggerClose;


	      modal.show();
	      modal.$content.find(triggerClose).focus();
	    }
	  }, {
	    key: 'hideAlert',
	    value: function hideAlert() {
	      this.modal.hide();
	    }
	  }, {
	    key: 'buildHtml',
	    value: function buildHtml(textMessage, textButton) {
	      return '\n      <div>\n        <div class="container-fluid align-center">\n          <div class="row">\n            <div class="col-xs-12">\n              <p data-alert-text>' + textMessage + '</p>\n            </div>\n            <div class="row">\n              <div class="col-xs-offset-2 col-xs-8 col-md-offset-4 col-md-4">\n                <button class="button button-primary button-full" data-alert-button>\n                  ' + textButton + '\n                </button>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    ';
	    }
	  }]);

	  return Alert;
	}();

	/* istanbul ignore next */


	_jquery2.default.fn[NAME] = function (options) {
	  return _jquery2.default.data(this, NAME, new Alert(options).init());
	};

	/* istanbul ignore next */

	exports.default = function (options) {
	  return new Alert(options).init();
	};

		exports.Alert = Alert;

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = $;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _jquery = __webpack_require__(3);

	var _jquery2 = _interopRequireDefault(_jquery);

	var _emitter = __webpack_require__(5);

	var _emitter2 = _interopRequireDefault(_emitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var NAME = 'modal';
	var HASH = '#modal-open';

	var templates = {
	  modal: '<div class="modal"></div>',
	  close: '<i class="modal-close glyph glyph-x"></i>',
	  content: '<div class="modal-content"><div class="modal-body"></div></div>'
	};

	var DEFAULTS = {
	  container: 'body',
	  size: 'medium',
	  triggerClose: null,
	  static: false,
	  keyboard: true,
	  history: false,
	  keys: { esc: 27 },
	  triggerOpen: null
	};

	var Modal = function () {
	  function Modal(element, options) {
	    _classCallCheck(this, Modal);

	    this.$element = element instanceof _jquery2.default ? element : (0, _jquery2.default)(element);
	    this.options = _jquery2.default.extend({}, DEFAULTS, options || {});
	  }

	  _createClass(Modal, [{
	    key: 'init',
	    value: function init() {
	      this.$container = (0, _jquery2.default)(this.options.container);
	      this.createModal();

	      return this;
	    }
	  }, {
	    key: 'show',
	    value: function show() {
	      this.bindListeners();
	      this.showModal();
	    }
	  }, {
	    key: 'hide',
	    value: function hide() {
	      this.unbindListeners();
	      this.hideModal();
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this.$element.removeData(NAME);
	      this.$modal.remove();
	    }
	  }, {
	    key: 'bindListeners',
	    value: function bindListeners() {
	      if (this.options.triggerClose) {
	        this.$modal.on('click', this.options.triggerClose, this.hide.bind(this));
	      }

	      this.$close.on('click', this.hide.bind(this));

	      this.bindKeyboardListener();

	      if (this.options.history) {
	        this.bindModalShowListener();
	        this.bindHashChangeListener();
	        this.bindModalHideListener();
	      }
	    }
	  }, {
	    key: 'bindKeyboardListener',
	    value: function bindKeyboardListener() {
	      var _this = this;

	      if (this.options.keyboard) {
	        (0, _jquery2.default)(window).on('keyup', function (e) {
	          var esc = _this.options.keys.esc;

	          var key = e.which;

	          if (key === esc) {
	            _this.hide();
	          }
	        });
	      }
	    }
	  }, {
	    key: 'bindModalShowListener',
	    value: function bindModalShowListener() {
	      _emitter2.default.on('modal:show', function () {
	        window.location.hash = HASH;
	      });
	    }
	  }, {
	    key: 'bindHashChangeListener',
	    value: function bindHashChangeListener() {
	      var _this2 = this;

	      (0, _jquery2.default)(window).on('hashchange', function () {
	        if (window.location.hash) {
	          return;
	        }

	        _this2.hide();
	      });
	    }
	  }, {
	    key: 'bindModalHideListener',
	    value: function bindModalHideListener() {
	      _emitter2.default.on('modal:hide', function () {
	        history.back();
	      });
	    }
	  }, {
	    key: 'unbindListeners',
	    value: function unbindListeners() {
	      if (this.options.triggerClose) {
	        this.$modal.off('click', this.options.triggerClose, this.hide.bind(this));
	      }

	      this.$close.off('click');
	      (0, _jquery2.default)(window).off('keyup', this.handler);
	    }
	  }, {
	    key: 'bindTrigger',
	    value: function bindTrigger() {
	      if (this.options.triggerOpen) {
	        (0, _jquery2.default)(this.options.triggerOpen).on('click', this.onTriggerOpenClick.bind(this));
	      }
	    }
	  }, {
	    key: 'onTriggerOpenClick',
	    value: function onTriggerOpenClick(event) {
	      event.preventDefault();
	      this.show();
	    }
	  }, {
	    key: 'showModal',
	    value: function showModal() {
	      var _this3 = this;

	      _emitter2.default.emit('modal:show');
	      _emitter2.default.removeAllListeners('modal:show');

	      this.$modal.addClass('modal-enter');
	      this.$content.addClass('modal-content-enter');
	      this.$container.addClass('no-scroll');

	      window.setTimeout(function () {
	        _this3.$modal.addClass('modal-show');
	        _this3.$content.addClass('modal-content-show');
	      }, 200);

	      this.$modal.on('click', this.onModalClick.bind(this));
	    }
	  }, {
	    key: 'hideModal',
	    value: function hideModal() {
	      var _this4 = this;

	      if (window.location.hash) {
	        _emitter2.default.emit('modal:hide');
	      }
	      _emitter2.default.removeAllListeners('modal:hide');

	      this.$content.removeClass('modal-content-show').addClass('modal-content-leave');

	      this.$modal.removeClass('modal-show').addClass('modal-leave');

	      this.$container.removeClass('no-scroll');

	      window.setTimeout(function () {
	        _this4.$modal.removeClass('modal-enter modal-leave');
	        _this4.$content.removeClass('modal-content-enter modal-content-leave');
	      }, 200);
	    }
	  }, {
	    key: 'onModalClick',
	    value: function onModalClick(event) {
	      if (!this.isStaticModal() && this.$modal.is(event.target)) {
	        this.hideModal();
	      }
	    }
	  }, {
	    key: 'fillModal',
	    value: function fillModal() {
	      this.$content.find('.modal-body').append(this.$element.html());
	    }
	  }, {
	    key: 'createModal',
	    value: function createModal() {
	      this.$modal = (0, _jquery2.default)(templates.modal);
	      this.$content = (0, _jquery2.default)(templates.content);
	      this.$close = (0, _jquery2.default)(templates.close);

	      this.$content.addClass(this.setupSizeModal(this.options.size));

	      if (!this.isStaticModal()) {
	        this.$content.append(this.$close);
	      }

	      this.$modal.append(this.$content);

	      this.$container.append(this.$modal);

	      this.bindTrigger();
	      this.fillModal();
	    }
	  }, {
	    key: 'isStaticModal',
	    value: function isStaticModal() {
	      return this.options.static;
	    }
	  }, {
	    key: 'setupSizeModal',
	    value: function setupSizeModal(size) {
	      var sizes = {
	        'small': 'modal-content-sm',
	        'medium': 'modal-content-md',
	        'large': 'modal-content-lg'
	      };

	      return sizes[size];
	    }
	  }]);

	  return Modal;
	}();

	/* istanbul ignore next */


	_jquery2.default.fn[NAME] = function (options) {
	  options = options || {};

	  return this.each(function () {
	    if (!_jquery2.default.data(this, NAME)) {
	      _jquery2.default.data(this, NAME, new Modal(this, options).init());
	    }
	  });
	};

	exports.default = Modal;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _events = __webpack_require__(6);

	var _events2 = _interopRequireDefault(_events);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		exports.default = new _events2.default();

/***/ },
/* 6 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];

	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _jquery = __webpack_require__(3);

	var _jquery2 = _interopRequireDefault(_jquery);

	var _emitter = __webpack_require__(5);

	var _emitter2 = _interopRequireDefault(_emitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var NAME = 'collapse';
	var DEFAULTS = {
	  selector: 'data-target',
	  listener: 'click',
	  activeClass: 'active',
	  visibleClass: 'visible',
	  timing: 300
	};

	var Collapse = function () {
	  function Collapse(element, options) {
	    _classCallCheck(this, Collapse);

	    this.$element = (0, _jquery2.default)(element);

	    this.options = _jquery2.default.extend({}, DEFAULTS, options || {});
	  }

	  _createClass(Collapse, [{
	    key: 'init',
	    value: function init() {
	      this.$toggle = (0, _jquery2.default)(this.$element.attr(this.options.selector));
	      this.toggle = this.$toggle[0];

	      this.setInitialState();
	      this.bindListeners();

	      return this;
	    }
	  }, {
	    key: 'setInitialState',
	    value: function setInitialState() {
	      var _this = this;

	      this.isCollapsed = !this.$toggle.hasClass(this.options.visibleClass);

	      setTimeout(function () {
	        _this.toggleHeight = _this.toggle.scrollHeight;
	      }, this.options.timing);

	      if (!this.isCollapsed) {
	        this.toggle.style.maxHeight = this.toggleHeight + 'px';
	      }
	    }
	  }, {
	    key: 'bindListeners',
	    value: function bindListeners() {
	      this.$element.on(this.options.listener, this.toggleTarget.bind(this));
	    }
	  }, {
	    key: 'toggleTarget',
	    value: function toggleTarget() {
	      if (this.isCollapsed) {
	        this.showTarget();
	      } else {
	        this.hideTarget();
	      }
	    }
	  }, {
	    key: 'hideTarget',
	    value: function hideTarget() {
	      this.isCollapsed = true;

	      this.toggle.style.maxHeight = '';
	      this.$toggle.removeClass(this.options.visibleClass);
	      this.$element.removeClass(this.options.activeClass);

	      _emitter2.default.emit('collapse:hide', this.$element, this.$toggle);
	    }
	  }, {
	    key: 'showTarget',
	    value: function showTarget() {
	      this.isCollapsed = false;

	      this.toggle.style.maxHeight = this.toggleHeight + 'px';
	      this.$toggle.addClass(this.options.visibleClass);
	      this.$element.addClass(this.options.activeClass);

	      _emitter2.default.emit('collapse:show', this.$element, this.$toggle);
	    }
	  }]);

	  return Collapse;
	}();

	/* istanbul ignore next */


	_jquery2.default.fn[NAME] = function (options) {
	  options = options || {};

	  return this.each(function () {
	    if (!_jquery2.default.data(this, NAME)) {
	      _jquery2.default.data(this, NAME, new Collapse(this, options).init());
	    }
	  });
	};

	exports.default = Collapse;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Confirm = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _jquery = __webpack_require__(3);

	var _jquery2 = _interopRequireDefault(_jquery);

	var _modal = __webpack_require__(4);

	var _modal2 = _interopRequireDefault(_modal);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var NAME = 'confirm';

	var DEFAULTS = {
	  textMessage: 'This is an example message',
	  textConfirmButton: 'Ok',
	  textCancelButton: 'Cancel',
	  size: 'medium',
	  static: true,
	  triggerCancel: '[data-cancel-button]',
	  triggerConfirm: '[data-confirm-button]'
	};

	var Confirm = function () {
	  function Confirm(callback) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Confirm);

	    this.options = _jquery2.default.extend({}, DEFAULTS, options);
	    this.callback = callback;
	  }

	  _createClass(Confirm, [{
	    key: 'init',
	    value: function init() {
	      this.setupConfirm();
	      this.setupElements();
	      this.bindListeners();
	      this.showConfirm();
	    }
	  }, {
	    key: 'setupConfirm',
	    value: function setupConfirm() {
	      this.$element = (0, _jquery2.default)(this.buildHtml(this.options));

	      this.modal = this.$element.modal(this.options).data('modal');
	    }
	  }, {
	    key: 'setupElements',
	    value: function setupElements() {
	      var $content = this.modal.$content;

	      this.$confirmButton = $content.find(this.options.triggerConfirm);
	      this.$cancelButton = $content.find(this.options.triggerCancel);
	    }
	  }, {
	    key: 'bindListeners',
	    value: function bindListeners() {
	      this.$confirmButton.on('click', this.onConfirmClick.bind(this));
	      this.$cancelButton.on('click', this.onCancelClick.bind(this));
	    }
	  }, {
	    key: 'onConfirmClick',
	    value: function onConfirmClick() {
	      this.callback(true);
	      this.hideConfirm();
	    }
	  }, {
	    key: 'onCancelClick',
	    value: function onCancelClick() {
	      this.callback(false);
	      this.hideConfirm();
	    }
	  }, {
	    key: 'showConfirm',
	    value: function showConfirm() {
	      this.modal.show();
	      this.$confirmButton.focus();
	    }
	  }, {
	    key: 'hideConfirm',
	    value: function hideConfirm() {
	      this.modal.hide();
	    }
	  }, {
	    key: 'buildHtml',
	    value: function buildHtml(_ref) {
	      var textMessage = _ref.textMessage,
	          textConfirmButton = _ref.textConfirmButton,
	          textCancelButton = _ref.textCancelButton;

	      return '\n      <div>\n        <div class="container-fluid align-center">\n          <div class="row">\n            <div class="col-xs-12">\n              <p data-confirm-text>' + textMessage + '</p>\n            </div>\n            <div class="row">\n              <div class="col-xs-offset-2 col-xs-5 col-md-4">\n                <button class="button button-primary button-full" data-confirm-button>\n                  ' + textConfirmButton + '\n                </button>\n              </div>\n              <div class="col-xs-5 col-md-4">\n                <button class="button button-full" data-cancel-button>\n                  ' + textCancelButton + '\n                </button>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    ';
	    }
	  }]);

	  return Confirm;
	}();

	/* istanbul ignore next */


	_jquery2.default.fn[NAME] = function (callback, options) {
	  return _jquery2.default.data(this, NAME, new Confirm(callback, options).init());
	};

	/* istanbul ignore next */

	exports.default = function (callback, options) {
	  return new Confirm(callback, options).init();
	};

		exports.Confirm = Confirm;

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _jquery = __webpack_require__(3);

	var _jquery2 = _interopRequireDefault(_jquery);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var NAME = 'form';
	var DEFAULTS = {
	  events: 'change',
	  selectors: '.input, select, .select, .textarea'
	};

	var Form = function () {
	  function Form(element, options) {
	    _classCallCheck(this, Form);

	    this.$element = (0, _jquery2.default)(element);
	    this.options = _jquery2.default.extend({}, DEFAULTS, options || {});

	    this.bindListeners();

	    this.toggleFieldsActiveClass();
	  }

	  _createClass(Form, [{
	    key: 'bindListeners',
	    value: function bindListeners() {
	      (0, _jquery2.default)(document).on(this.options.events, this.options.selectors, this.onFieldChange.bind(this));
	    }
	  }, {
	    key: 'onFieldChange',
	    value: function onFieldChange(event) {
	      this.toggleActiveClass(event.target);
	    }
	  }, {
	    key: 'shouldInputBeActive',
	    value: function shouldInputBeActive($input) {
	      var value = $input.val();

	      if ($input.is('select')) {
	        value = $input.find('option:selected').text().trim();
	      }

	      return !!value;
	    }
	  }, {
	    key: 'toggleActiveClass',
	    value: function toggleActiveClass(input) {
	      var $input = (0, _jquery2.default)(input);
	      var $field = $input.parents('.field');

	      if (!$field.length) {
	        return;
	      }

	      if (!$field.hasClass('active') && this.shouldInputBeActive($input)) {
	        return $field.addClass('active');
	      }

	      if ($field.hasClass('active') && !this.shouldInputBeActive($input)) {
	        return $field.removeClass('active');
	      }
	    }
	  }, {
	    key: 'toggleFieldsActiveClass',
	    value: function toggleFieldsActiveClass() {
	      Array.prototype.forEach.call((0, _jquery2.default)(document).find(this.options.selectors), this.toggleActiveClass.bind(this));
	    }
	  }]);

	  return Form;
	}();

	/* istanbul ignore next */


	_jquery2.default.fn[NAME] = function (options) {
	  options = options || {};

	  return this.each(function () {
	    if (!_jquery2.default.data(this, NAME)) {
	      _jquery2.default.data(this, NAME, new Form(this, options));
	    }
	  });
	};

	exports.default = Form;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _jquery = __webpack_require__(3);

	var _jquery2 = _interopRequireDefault(_jquery);

	var _throttle = __webpack_require__(11);

	var _throttle2 = _interopRequireDefault(_throttle);

	var _removeArrayLike = __webpack_require__(12);

	var _removeArrayLike2 = _interopRequireDefault(_removeArrayLike);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var NAME = 'lazyload';
	var DEFAULTS = {
	  throttle: 1000,
	  offset: 200,
	  selector: 'data-lazy'
	};

	var LazyLoad = function () {
	  function LazyLoad(element, options) {
	    _classCallCheck(this, LazyLoad);

	    this.$element = (0, _jquery2.default)(element);
	    this.options = _jquery2.default.extend({}, DEFAULTS, options || {});
	  }

	  _createClass(LazyLoad, [{
	    key: 'init',
	    value: function init() {
	      this.bindListeners();
	      this.checkVisiblePlaceholders();

	      return this;
	    }
	  }, {
	    key: 'bindListeners',
	    value: function bindListeners() {
	      this.onScrollHandler = (0, _throttle2.default)(this.onScroll.bind(this), this.options.throttle);
	      (0, _jquery2.default)(window).on('scroll', this.onScrollHandler);
	    }
	  }, {
	    key: 'onScroll',
	    value: function onScroll() {
	      return this.$element.length ? this.checkVisiblePlaceholders() : (0, _jquery2.default)(window).off('scroll', this.onScrollHandler);
	    }
	  }, {
	    key: 'checkVisiblePlaceholders',
	    value: function checkVisiblePlaceholders() {
	      this.windowHeight = (0, _jquery2.default)(window).height();
	      this.windowWidth = (0, _jquery2.default)(window).width();

	      Array.prototype.forEach.call(this.$element, this.checkPlaceholder.bind(this));
	    }
	  }, {
	    key: 'checkPlaceholder',
	    value: function checkPlaceholder(placeholder) {
	      if (this.isPlaceholderVisible(placeholder)) {
	        this.renderImage(placeholder);
	        (0, _removeArrayLike2.default)(this.$element, placeholder);
	      }
	    }
	  }, {
	    key: 'isPlaceholderVisible',
	    value: function isPlaceholderVisible(placeholder) {
	      return placeholder.getBoundingClientRect().top <= this.windowHeight + this.options.offset;
	    }
	  }, {
	    key: 'renderImage',
	    value: function renderImage(placeholder) {
	      placeholder.parentNode.replaceChild(this.createImage(placeholder), placeholder);
	    }
	  }, {
	    key: 'createImage',
	    value: function createImage(placeholder) {
	      var image = document.createElement('img');

	      this.parseAttributes(image, placeholder.attributes);

	      image.removeAttribute('data-lazy');

	      if (placeholder.getAttribute('data-srcset')) {
	        this.parseBreakpoints(image, placeholder.getAttribute('data-srcset'));

	        return image;
	      }

	      image.src = placeholder.getAttribute('data-src');

	      return image;
	    }
	  }, {
	    key: 'parseAttributes',
	    value: function parseAttributes(image, attributes) {
	      var _this = this;

	      Array.prototype.forEach.call(attributes, function (attr) {
	        if (attr.name !== _this.options.selector || attr.name !== 'data-srcset' || attr.name !== 'data-src') {
	          image.setAttribute(attr.name, attr.value);
	        }
	      });

	      return image;
	    }
	  }, {
	    key: 'parseBreakpoints',
	    value: function parseBreakpoints(image, breakpoints) {
	      image.removeAttribute('data-srcset');

	      breakpoints = breakpoints.split(/,\s+/g).map(function (breakpoint) {
	        breakpoint = breakpoint.trim().split(/\s+/);

	        return {
	          src: breakpoint[0],
	          width: breakpoint[1]
	        };
	      }).sort(function (a, b) {
	        return b.width - a.width;
	      });

	      for (var i = 0; i < breakpoints.length; i++) {
	        var breakpoint = breakpoints[i];

	        if (breakpoint.width <= this.windowWidth) {
	          image.src = breakpoint.src;
	          break;
	        }
	      }

	      return image;
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      (0, _jquery2.default)(window).off('scroll', this.onScrollHandler);
	    }
	  }]);

	  return LazyLoad;
	}();

	/* istanbul ignore next */


	_jquery2.default.fn[NAME] = function (options) {
	  options = options || {};

	  return this.each(function () {
	    if (!_jquery2.default.data(this, NAME)) {
	      _jquery2.default.data(this, NAME, new LazyLoad(this, options).init());
	    }
	  });
	};

	exports.default = LazyLoad;

/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (fn, timer) {
	  var wait = true;

	  return function () {
	    if (wait) {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      fn.apply(this, args);

	      wait = false;

	      setTimeout(function () {
	        wait = true;
	        return wait;
	      }, timer);
	    }
	  };
	};

/***/ },
/* 12 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (arr, item) {
	  Array.prototype.splice.call(arr, Array.prototype.indexOf.call(arr, item));
	};

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _jquery = __webpack_require__(3);

	var _jquery2 = _interopRequireDefault(_jquery);

	var _transitionend = __webpack_require__(14);

	var _transitionend2 = _interopRequireDefault(_transitionend);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var NAME = 'notification';

	var DEFAULTS = {
	  autoHide: false,
	  closeButton: '.' + NAME + '-close',
	  dynamic: true,
	  hideIn: 3000,
	  message: null,
	  showIn: 1000,
	  type: 'primary'
	};

	var classNames = {
	  hide: NAME + '-hide',
	  show: NAME + '-show',
	  enter: NAME + '-enter',
	  leave: NAME + '-leave',
	  close: NAME + '-close'
	};

	var templates = {
	  box: '<div class="' + NAME + ' ' + classNames.enter + '"></div>',
	  close: '<i class="' + classNames.close + ' glyph glyph-x"></i>'
	};

	var Notification = function () {
	  function Notification(element, options) {
	    _classCallCheck(this, Notification);

	    this.$element = element instanceof _jquery2.default ? element : (0, _jquery2.default)(element);
	    this.options = _jquery2.default.extend({}, DEFAULTS, options);
	  }

	  /**
	   * Init notification, insert notifiction into DOM, bind close button and
	   * show notifiction based on showIn config
	   */


	  _createClass(Notification, [{
	    key: 'init',
	    value: function init() {
	      var _this = this;

	      this._createNotification();
	      this.bindListeners();

	      if (!this.options.dynamic) {
	        return this;
	      }

	      window.setTimeout(function () {
	        _this.show();
	      }, this.options.showIn);

	      return this;
	    }

	    /**
	     * Bind close button
	     */

	  }, {
	    key: 'bindListeners',
	    value: function bindListeners() {
	      var _this2 = this;

	      this.$closeHandler = function () {
	        _this2.hide();
	      };

	      this.$close.on('click', this.$closeHandler);
	    }

	    /**
	     * show notification, if autoHide is true, hide box after hideIn timing config
	     */

	  }, {
	    key: 'show',
	    value: function show() {
	      var _this3 = this;

	      this.$box.addClass(classNames.show).removeClass(classNames.hide);

	      if (this.options.autoHide) {
	        window.setTimeout(function () {
	          _this3.hide();
	        }, this.options.hideIn);
	      }
	    }

	    /**
	     * hide notification and after hide animation finish, add display: none to element
	     */

	  }, {
	    key: 'hide',
	    value: function hide() {
	      var _this4 = this;

	      this.$box.removeClass(classNames.show).addClass(classNames.leave);

	      this.$box.on((0, _transitionend2.default)(), function () {
	        _this4.$box.addClass(classNames.hide).removeClass(classNames.enter).removeClass(classNames.leave);
	      });
	    }

	    /**
	     * Remove data from $element, unbind close button and remove box from DOM
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this.$element.removeData(NAME);
	      this.$close.off('click', this.$closeHandler);
	      this.$box.remove();
	    }

	    /**
	     * Add notification class, append close button and message
	     */

	  }, {
	    key: '_createNotification',
	    value: function _createNotification() {
	      if (!this.options.dynamic) {
	        this.$box = this.$element;
	        this._createCloseButton();

	        return;
	      }

	      if (!this.options.message) {
	        return;
	      }

	      this.$box = (0, _jquery2.default)(templates.box);
	      this.$box.addClass(NAME + '-' + this.options.type);
	      this.$box.html(this.options.message);

	      this._createCloseButton();
	      this.$element.append(this.$box);
	    }
	  }, {
	    key: '_createCloseButton',
	    value: function _createCloseButton() {
	      if (!this.options.dynamic) {
	        this.$close = this.$box.find(this.options.closeButton);

	        return this.$close;
	      }

	      this.$close = (0, _jquery2.default)(templates.close);
	      this.$box.append(this.$close);
	    }
	  }]);

	  return Notification;
	}();

	/* istanbul ignore next */


	_jquery2.default.fn[NAME] = function (options) {
	  options = options || {};

	  return this.each(function () {
	    if (!_jquery2.default.data(this, NAME)) {
	      _jquery2.default.data(this, NAME, new Notification(this, options).init());
	    }
	  });
	};

	exports.default = Notification;

/***/ },
/* 14 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function () {
	  var eventNames = {
	    WebkitTransition: 'webkitTransitionEnd',
	    MozTransition: 'transitionend',
	    OTransition: 'oTransitionEnd otransitionend',
	    msTransition: 'MsTransitionEnd',
	    transition: 'transitionend'
	  };

	  var el = document.createElement('div');

	  for (var transition in eventNames) {
	    if (el.style[transition] !== undefined) {
	      return eventNames[transition];
	    }
	  }
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _jquery = __webpack_require__(3);

	var _jquery2 = _interopRequireDefault(_jquery);

	var _scroll = __webpack_require__(16);

	var _scroll2 = _interopRequireDefault(_scroll);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Scroll component. There is no need to create a new instance to it, since it won't listen to events,
	 * nor anything dynamic.
	 */
	var NAME = 'scroll';

	var DEFAULTS = {
	  duration: 500,
	  offset: -30
	};

	/* istanbul ignore next */
	_jquery2.default.fn[NAME] = function (options) {
	  options = options || {};

	  return this.each(function () {
	    (0, _scroll2.default)(this, _jquery2.default.extend({}, DEFAULTS, options || {}));
	  });
	};

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _jquery = __webpack_require__(3);

	var _jquery2 = _interopRequireDefault(_jquery);

	var _jump = __webpack_require__(17);

	var _jump2 = _interopRequireDefault(_jump);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Util responsible to handle animated scroll with the usage of a third party plugin called Jump.js.
	 */
	var DEFAULTS = {
	  duration: 500,
	  offset: -30
	};

	/**
	 * Default scroll method
	 * @param  {element} el      The element to scroll to. Accepts both vanilla and $ selector
	 * @param  {object}  options The options available on Jump.js @method jump. Will extend from the DEFAULTS const.
	 */

	exports.default = function (el, options) {
	  return new _jump2.default(el instanceof _jquery2.default ? el[0] : el, _jquery2.default.extend({}, DEFAULTS, options));
		};

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	(function (global, factory) {
	  ( false ? 'undefined' : _typeof2(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.Jump = factory();
	})(undefined, function () {
	  'use strict';

	  // Robert Penner's easeInOutQuad

	  // find the rest of his easing functions here: http://robertpenner.com/easing/
	  // find them exported for ES6 consumption here: https://github.com/jaxgeller/ez.js

	  var easeInOutQuad = function easeInOutQuad(t, b, c, d) {
	    t /= d / 2;
	    if (t < 1) return c / 2 * t * t + b;
	    t--;
	    return -c / 2 * (t * (t - 2) - 1) + b;
	  };

	  var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	    return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
	  } : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
	  };

	  var jumper = function jumper() {
	    // private variable cache
	    // no variables are created during a jump, preventing memory leaks

	    var element = void 0; // element to scroll to                   (node)

	    var start = void 0; // where scroll starts                    (px)
	    var stop = void 0; // where scroll stops                     (px)

	    var offset = void 0; // adjustment from the stop position      (px)
	    var easing = void 0; // easing function                        (function)
	    var a11y = void 0; // accessibility support flag             (boolean)

	    var distance = void 0; // distance of scroll                     (px)
	    var duration = void 0; // scroll duration                        (ms)

	    var timeStart = void 0; // time scroll started                    (ms)
	    var timeElapsed = void 0; // time spent scrolling thus far          (ms)

	    var next = void 0; // next scroll position                   (px)

	    var callback = void 0; // to call when done scrolling            (function)

	    // scroll position helper

	    function location() {
	      return window.scrollY || window.pageYOffset;
	    }

	    // element offset helper

	    function top(element) {
	      return element.getBoundingClientRect().top + start;
	    }

	    // rAF loop helper

	    function loop(timeCurrent) {
	      // store time scroll started, if not started already
	      if (!timeStart) {
	        timeStart = timeCurrent;
	      }

	      // determine time spent scrolling so far
	      timeElapsed = timeCurrent - timeStart;

	      // calculate next scroll position
	      next = easing(timeElapsed, start, distance, duration);

	      // scroll to it
	      window.scrollTo(0, next);

	      // check progress
	      timeElapsed < duration ? window.requestAnimationFrame(loop) // continue scroll loop
	      : done(); // scrolling is done
	    }

	    // scroll finished helper

	    function done() {
	      // account for rAF time rounding inaccuracies
	      window.scrollTo(0, start + distance);

	      // if scrolling to an element, and accessibility is enabled
	      if (element && a11y) {
	        // add tabindex indicating programmatic focus
	        element.setAttribute('tabindex', '-1');

	        // focus the element
	        element.focus();
	      }

	      // if it exists, fire the callback
	      if (typeof callback === 'function') {
	        callback();
	      }

	      // reset time for next jump
	      timeStart = false;
	    }

	    // API

	    function jump(target) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	      // resolve options, or use defaults
	      duration = options.duration || 1000;
	      offset = options.offset || 0;
	      callback = options.callback; // "undefined" is a suitable default, and won't be called
	      easing = options.easing || easeInOutQuad;
	      a11y = options.a11y || false;

	      // cache starting position
	      start = location();

	      // resolve target
	      switch (typeof target === 'undefined' ? 'undefined' : _typeof(target)) {
	        // scroll from current position
	        case 'number':
	          element = undefined; // no element to scroll to
	          a11y = false; // make sure accessibility is off
	          stop = start + target;
	          break;

	        // scroll to element (node)
	        // bounding rect is relative to the viewport
	        case 'object':
	          element = target;
	          stop = top(element);
	          break;

	        // scroll to element (selector)
	        // bounding rect is relative to the viewport
	        case 'string':
	          element = document.querySelector(target);
	          stop = top(element);
	          break;
	      }

	      // resolve scroll distance, accounting for offset
	      distance = stop - start + offset;

	      // resolve duration
	      switch (_typeof(options.duration)) {
	        // number in ms
	        case 'number':
	          duration = options.duration;
	          break;

	        // function passed the distance of the scroll
	        case 'function':
	          duration = options.duration(distance);
	          break;
	      }

	      // start the loop
	      window.requestAnimationFrame(loop);
	    }

	    // expose only the jump method
	    return jump;
	  };

	  // export singleton

	  var singleton = jumper();

	  return singleton;
		});

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _popper = __webpack_require__(19);

	var _popper2 = _interopRequireDefault(_popper);

	var _jquery = __webpack_require__(3);

	var _jquery2 = _interopRequireDefault(_jquery);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var NAME = 'tooltip';

	var DEFAULTS = {
	  placement: 'top'
	};

	var Tooltip = function () {
	  function Tooltip(element) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Tooltip);

	    this.$element = (0, _jquery2.default)(element);
	    this.$target = this._getTarget();
	    this.options = _jquery2.default.extend({}, DEFAULTS, options);
	  }

	  _createClass(Tooltip, [{
	    key: 'init',
	    value: function init() {
	      this._registerPopper();

	      return this;
	    }
	  }, {
	    key: '_getTarget',
	    value: function _getTarget() {
	      var targetName = this.$element.data(NAME);
	      return this.$element.find(targetName);
	    }
	  }, {
	    key: '_buildPopper',
	    value: function _buildPopper() {
	      return new _popper2.default(this.$element[0], this.$target[0], this.options);
	    }
	  }, {
	    key: '_registerPopper',
	    value: function _registerPopper() {
	      var popper = this._buildPopper();

	      this.$element.data('popper', popper);
	    }
	  }]);

	  return Tooltip;
	}();

	/* istanbul ignore next */


	_jquery2.default.fn[NAME] = function (options) {
	  options = options || {};

	  return this.each(function () {
	    if (!_jquery2.default.data(this, NAME)) {
	      _jquery2.default.data(this, NAME, new Tooltip(this, options).init());
	    }
	  });
	};

	exports.default = Tooltip;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	(function (global, factory) {
	  ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.Popper = factory();
	})(undefined, function () {
	  'use strict';

	  var nativeHints = ['native code', '[object MutationObserverConstructor]'];

	  /**
	   * Determine if a function is implemented natively (as opposed to a polyfill).
	   * @method
	   * @memberof Popper.Utils
	   * @argument {Function | undefined} fn the function to check
	   * @returns {Boolean}
	   */
	  var isNative = function isNative(fn) {
	    return nativeHints.some(function (hint) {
	      return (fn || '').toString().indexOf(hint) > -1;
	    });
	  };

	  var isBrowser = typeof window !== 'undefined';
	  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
	  var timeoutDuration = 0;
	  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
	    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
	      timeoutDuration = 1;
	      break;
	    }
	  }

	  function microtaskDebounce(fn) {
	    var scheduled = false;
	    var i = 0;
	    var elem = document.createElement('span');

	    // MutationObserver provides a mechanism for scheduling microtasks, which
	    // are scheduled *before* the next task. This gives us a way to debounce
	    // a function but ensure it's called *before* the next paint.
	    var observer = new MutationObserver(function () {
	      fn();
	      scheduled = false;
	    });

	    observer.observe(elem, { attributes: true });

	    return function () {
	      if (!scheduled) {
	        scheduled = true;
	        elem.setAttribute('x-index', i);
	        i = i + 1; // don't use compund (+=) because it doesn't get optimized in V8
	      }
	    };
	  }

	  function taskDebounce(fn) {
	    var scheduled = false;
	    return function () {
	      if (!scheduled) {
	        scheduled = true;
	        setTimeout(function () {
	          scheduled = false;
	          fn();
	        }, timeoutDuration);
	      }
	    };
	  }

	  // It's common for MutationObserver polyfills to be seen in the wild, however
	  // these rely on Mutation Events which only occur when an element is connected
	  // to the DOM. The algorithm used in this module does not use a connected element,
	  // and so we must ensure that a *native* MutationObserver is available.
	  var supportsNativeMutationObserver = isBrowser && isNative(window.MutationObserver);

	  /**
	  * Create a debounced version of a method, that's asynchronously deferred
	  * but called in the minimum time possible.
	  *
	  * @method
	  * @memberof Popper.Utils
	  * @argument {Function} fn
	  * @returns {Function}
	  */
	  var debounce = supportsNativeMutationObserver ? microtaskDebounce : taskDebounce;

	  /**
	   * Tells if a given input is a number
	   * @method
	   * @memberof Popper.Utils
	   * @param {*} input to check
	   * @return {Boolean}
	   */
	  function isNumeric(n) {
	    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
	  }

	  /**
	   * Set the style to the given popper
	   * @method
	   * @memberof Popper.Utils
	   * @argument {Element} element - Element to apply the style to
	   * @argument {Object} styles
	   * Object with a list of properties and values which will be applied to the element
	   */
	  function setStyles(element, styles) {
	    Object.keys(styles).forEach(function (prop) {
	      var unit = '';
	      // add unit if the value is numeric and is one of the following
	      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
	        unit = 'px';
	      }
	      element.style[prop] = styles[prop] + unit;
	    });
	  }

	  /**
	   * Check if the given variable is a function
	   * @method
	   * @memberof Popper.Utils
	   * @argument {Any} functionToCheck - variable to check
	   * @returns {Boolean} answer to: is a function?
	   */
	  function isFunction(functionToCheck) {
	    var getType = {};
	    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
	  }

	  /**
	   * Get CSS computed property of the given element
	   * @method
	   * @memberof Popper.Utils
	   * @argument {Eement} element
	   * @argument {String} property
	   */
	  function getStyleComputedProperty(element, property) {
	    if (element.nodeType !== 1) {
	      return [];
	    }
	    // NOTE: 1 DOM access here
	    var css = window.getComputedStyle(element, null);
	    return property ? css[property] : css;
	  }

	  /**
	   * Returns the parentNode or the host of the element
	   * @method
	   * @memberof Popper.Utils
	   * @argument {Element} element
	   * @returns {Element} parent
	   */
	  function getParentNode(element) {
	    if (element.nodeName === 'HTML') {
	      return element;
	    }
	    return element.parentNode || element.host;
	  }

	  /**
	   * Returns the scrolling parent of the given element
	   * @method
	   * @memberof Popper.Utils
	   * @argument {Element} element
	   * @returns {Element} scroll parent
	   */
	  function getScrollParent(element) {
	    // Return body, `getScroll` will take care to get the correct `scrollTop` from it
	    if (!element || ['HTML', 'BODY', '#document'].indexOf(element.nodeName) !== -1) {
	      return window.document.body;
	    }

	    // Firefox want us to check `-x` and `-y` variations as well

	    var _getStyleComputedProp = getStyleComputedProperty(element),
	        overflow = _getStyleComputedProp.overflow,
	        overflowX = _getStyleComputedProp.overflowX,
	        overflowY = _getStyleComputedProp.overflowY;

	    if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {
	      return element;
	    }

	    return getScrollParent(getParentNode(element));
	  }

	  function isOffsetContainer(element) {
	    var nodeName = element.nodeName;

	    if (nodeName === 'BODY') {
	      return false;
	    }
	    return nodeName === 'HTML' || element.firstElementChild.offsetParent === element;
	  }

	  /**
	   * Finds the root node (document, shadowDOM root) of the given element
	   * @method
	   * @memberof Popper.Utils
	   * @argument {Element} node
	   * @returns {Element} root node
	   */
	  function getRoot(node) {
	    if (node.parentNode !== null) {
	      return getRoot(node.parentNode);
	    }

	    return node;
	  }

	  /**
	   * Returns the offset parent of the given element
	   * @method
	   * @memberof Popper.Utils
	   * @argument {Element} element
	   * @returns {Element} offset parent
	   */
	  function getOffsetParent(element) {
	    // NOTE: 1 DOM access here
	    var offsetParent = element && element.offsetParent;
	    var nodeName = offsetParent && offsetParent.nodeName;

	    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
	      return window.document.documentElement;
	    }

	    return offsetParent;
	  }

	  /**
	   * Finds the offset parent common to the two provided nodes
	   * @method
	   * @memberof Popper.Utils
	   * @argument {Element} element1
	   * @argument {Element} element2
	   * @returns {Element} common offset parent
	   */
	  function findCommonOffsetParent(element1, element2) {
	    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
	    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
	      return window.document.documentElement;
	    }

	    // Here we make sure to give as "start" the element that comes first in the DOM
	    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
	    var start = order ? element1 : element2;
	    var end = order ? element2 : element1;

	    // Get common ancestor container
	    var range = document.createRange();
	    range.setStart(start, 0);
	    range.setEnd(end, 0);
	    var commonAncestorContainer = range.commonAncestorContainer;

	    // Both nodes are inside #document

	    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
	      if (isOffsetContainer(commonAncestorContainer)) {
	        return commonAncestorContainer;
	      }

	      return getOffsetParent(commonAncestorContainer);
	    }

	    // one of the nodes is inside shadowDOM, find which one
	    var element1root = getRoot(element1);
	    if (element1root.host) {
	      return findCommonOffsetParent(element1root.host, element2);
	    } else {
	      return findCommonOffsetParent(element1, getRoot(element2).host);
	    }
	  }

	  /**
	   * Gets the scroll value of the given element in the given side (top and left)
	   * @method
	   * @memberof Popper.Utils
	   * @argument {Element} element
	   * @argument {String} side `top` or `left`
	   * @returns {number} amount of scrolled pixels
	   */
	  function getScroll(element) {
	    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

	    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
	    var nodeName = element.nodeName;

	    if (nodeName === 'BODY' || nodeName === 'HTML') {
	      var html = window.document.documentElement;
	      var scrollingElement = window.document.scrollingElement || html;
	      return scrollingElement[upperSide];
	    }

	    return element[upperSide];
	  }

	  /*
	   * Sum or subtract the element scroll values (left and top) from a given rect object
	   * @method
	   * @memberof Popper.Utils
	   * @param {Object} rect - Rect object you want to change
	   * @param {HTMLElement} element - The element from the function reads the scroll values
	   * @param {Boolean} subtract - set to true if you want to subtract the scroll values
	   * @return {Object} rect - The modifier rect object
	   */
	  function includeScroll(rect, element) {
	    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	    var scrollTop = getScroll(element, 'top');
	    var scrollLeft = getScroll(element, 'left');
	    var modifier = subtract ? -1 : 1;
	    rect.top += scrollTop * modifier;
	    rect.bottom += scrollTop * modifier;
	    rect.left += scrollLeft * modifier;
	    rect.right += scrollLeft * modifier;
	    return rect;
	  }

	  /*
	   * Helper to detect borders of a given element
	   * @method
	   * @memberof Popper.Utils
	   * @param {CSSStyleDeclaration} styles
	   * Result of `getStyleComputedProperty` on the given element
	   * @param {String} axis - `x` or `y`
	   * @return {number} borders - The borders size of the given axis
	   */

	  function getBordersSize(styles, axis) {
	    var sideA = axis === 'x' ? 'Left' : 'Top';
	    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

	    return +styles['border' + sideA + 'Width'].split('px')[0] + +styles['border' + sideB + 'Width'].split('px')[0];
	  }

	  /**
	   * Tells if you are running Internet Explorer 10
	   * @method
	   * @memberof Popper.Utils
	   * @returns {Boolean} isIE10
	   */
	  var isIE10 = undefined;

	  var isIE10$1 = function isIE10$1() {
	    if (isIE10 === undefined) {
	      isIE10 = navigator.appVersion.indexOf('MSIE 10') !== -1;
	    }
	    return isIE10;
	  };

	  function getSize(axis, body, html, computedStyle) {
	    return Math.max(body['offset' + axis], html['client' + axis], html['offset' + axis], isIE10$1() ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);
	  }

	  function getWindowSizes() {
	    var body = window.document.body;
	    var html = window.document.documentElement;
	    var computedStyle = isIE10$1() && window.getComputedStyle(html);

	    return {
	      height: getSize('Height', body, html, computedStyle),
	      width: getSize('Width', body, html, computedStyle)
	    };
	  }

	  var classCallCheck = function classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  };

	  var createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  var defineProperty = function defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }

	    return obj;
	  };

	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  /**
	   * Given element offsets, generate an output similar to getBoundingClientRect
	   * @method
	   * @memberof Popper.Utils
	   * @argument {Object} offsets
	   * @returns {Object} ClientRect like output
	   */
	  function getClientRect(offsets) {
	    return _extends({}, offsets, {
	      right: offsets.left + offsets.width,
	      bottom: offsets.top + offsets.height
	    });
	  }

	  /**
	   * Get bounding client rect of given element
	   * @method
	   * @memberof Popper.Utils
	   * @param {HTMLElement} element
	   * @return {Object} client rect
	   */
	  function getBoundingClientRect(element) {
	    var rect = {};

	    // IE10 10 FIX: Please, don't ask, the element isn't
	    // considered in DOM in some circumstances...
	    // This isn't reproducible in IE10 compatibility mode of IE11
	    if (isIE10$1()) {
	      try {
	        rect = element.getBoundingClientRect();
	        var scrollTop = getScroll(element, 'top');
	        var scrollLeft = getScroll(element, 'left');
	        rect.top += scrollTop;
	        rect.left += scrollLeft;
	        rect.bottom += scrollTop;
	        rect.right += scrollLeft;
	      } catch (err) {}
	    } else {
	      rect = element.getBoundingClientRect();
	    }

	    var result = {
	      left: rect.left,
	      top: rect.top,
	      width: rect.right - rect.left,
	      height: rect.bottom - rect.top
	    };

	    // subtract scrollbar size from sizes
	    var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};
	    var width = sizes.width || element.clientWidth || result.right - result.left;
	    var height = sizes.height || element.clientHeight || result.bottom - result.top;

	    var horizScrollbar = element.offsetWidth - width;
	    var vertScrollbar = element.offsetHeight - height;

	    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
	    // we make this check conditional for performance reasons
	    if (horizScrollbar || vertScrollbar) {
	      var styles = getStyleComputedProperty(element);
	      horizScrollbar -= getBordersSize(styles, 'x');
	      vertScrollbar -= getBordersSize(styles, 'y');

	      result.width -= horizScrollbar;
	      result.height -= vertScrollbar;
	    }

	    return getClientRect(result);
	  }

	  function getOffsetRectRelativeToArbitraryNode(children, parent) {
	    var isIE10 = isIE10$1();
	    var isHTML = parent.nodeName === 'HTML';
	    var childrenRect = getBoundingClientRect(children);
	    var parentRect = getBoundingClientRect(parent);
	    var scrollParent = getScrollParent(children);
	    var offsets = getClientRect({
	      top: childrenRect.top - parentRect.top,
	      left: childrenRect.left - parentRect.left,
	      width: childrenRect.width,
	      height: childrenRect.height
	    });

	    // Subtract margins of documentElement in case it's being used as parent
	    // we do this only on HTML because it's the only element that behaves
	    // differently when margins are applied to it. The margins are included in
	    // the box of the documentElement, in the other cases not.
	    if (isHTML || parent.nodeName === 'BODY') {
	      var styles = getStyleComputedProperty(parent);
	      var borderTopWidth = isIE10 && isHTML ? 0 : +styles.borderTopWidth.split('px')[0];
	      var borderLeftWidth = isIE10 && isHTML ? 0 : +styles.borderLeftWidth.split('px')[0];
	      var marginTop = isIE10 && isHTML ? 0 : +styles.marginTop.split('px')[0];
	      var marginLeft = isIE10 && isHTML ? 0 : +styles.marginLeft.split('px')[0];

	      offsets.top -= borderTopWidth - marginTop;
	      offsets.bottom -= borderTopWidth - marginTop;
	      offsets.left -= borderLeftWidth - marginLeft;
	      offsets.right -= borderLeftWidth - marginLeft;

	      // Attach marginTop and marginLeft because in some circumstances we may need them
	      offsets.marginTop = marginTop;
	      offsets.marginLeft = marginLeft;
	    }

	    if (isIE10 ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
	      offsets = includeScroll(offsets, parent);
	    }

	    return offsets;
	  }

	  function getViewportOffsetRectRelativeToArtbitraryNode(element) {
	    var html = window.document.documentElement;
	    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
	    var width = Math.max(html.clientWidth, window.innerWidth || 0);
	    var height = Math.max(html.clientHeight, window.innerHeight || 0);

	    var scrollTop = getScroll(html);
	    var scrollLeft = getScroll(html, 'left');

	    var offset = {
	      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
	      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
	      width: width,
	      height: height
	    };

	    return getClientRect(offset);
	  }

	  /**
	   * Check if the given element is fixed or is inside a fixed parent
	   * @method
	   * @memberof Popper.Utils
	   * @argument {Element} element
	   * @argument {Element} customContainer
	   * @returns {Boolean} answer to "isFixed?"
	   */
	  function isFixed(element) {
	    var nodeName = element.nodeName;
	    if (nodeName === 'BODY' || nodeName === 'HTML') {
	      return false;
	    }
	    if (getStyleComputedProperty(element, 'position') === 'fixed') {
	      return true;
	    }
	    return isFixed(getParentNode(element));
	  }

	  /**
	   * Computed the boundaries limits and return them
	   * @method
	   * @memberof Popper.Utils
	   * @param {HTMLElement} popper
	   * @param {HTMLElement} reference
	   * @param {number} padding
	   * @param {HTMLElement} boundariesElement - Element used to define the boundaries
	   * @returns {Object} Coordinates of the boundaries
	   */
	  function getBoundaries(popper, reference, padding, boundariesElement) {
	    // NOTE: 1 DOM access here
	    var boundaries = { top: 0, left: 0 };
	    var offsetParent = findCommonOffsetParent(popper, reference);

	    // Handle viewport case
	    if (boundariesElement === 'viewport') {
	      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent);
	    } else {
	      // Handle other cases based on DOM element used as boundaries
	      var boundariesNode = void 0;
	      if (boundariesElement === 'scrollParent') {
	        boundariesNode = getScrollParent(getParentNode(popper));
	        if (boundariesNode.nodeName === 'BODY') {
	          boundariesNode = window.document.documentElement;
	        }
	      } else if (boundariesElement === 'window') {
	        boundariesNode = window.document.documentElement;
	      } else {
	        boundariesNode = boundariesElement;
	      }

	      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent);

	      // In case of HTML, we need a different computation
	      if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
	        var _getWindowSizes = getWindowSizes(),
	            height = _getWindowSizes.height,
	            width = _getWindowSizes.width;

	        boundaries.top += offsets.top - offsets.marginTop;
	        boundaries.bottom = height + offsets.top;
	        boundaries.left += offsets.left - offsets.marginLeft;
	        boundaries.right = width + offsets.left;
	      } else {
	        // for all the other DOM elements, this one is good
	        boundaries = offsets;
	      }
	    }

	    // Add paddings
	    boundaries.left += padding;
	    boundaries.top += padding;
	    boundaries.right -= padding;
	    boundaries.bottom -= padding;

	    return boundaries;
	  }

	  function getArea(_ref) {
	    var width = _ref.width,
	        height = _ref.height;

	    return width * height;
	  }

	  /**
	   * Utility used to transform the `auto` placement to the placement with more
	   * available space.
	   * @method
	   * @memberof Popper.Utils
	   * @argument {Object} data - The data object generated by update method
	   * @argument {Object} options - Modifiers configuration and options
	   * @returns {Object} The data object, properly modified
	   */
	  function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
	    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

	    if (placement.indexOf('auto') === -1) {
	      return placement;
	    }

	    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

	    var rects = {
	      top: {
	        width: boundaries.width,
	        height: refRect.top - boundaries.top
	      },
	      right: {
	        width: boundaries.right - refRect.right,
	        height: boundaries.height
	      },
	      bottom: {
	        width: boundaries.width,
	        height: boundaries.bottom - refRect.bottom
	      },
	      left: {
	        width: refRect.left - boundaries.left,
	        height: boundaries.height
	      }
	    };

	    var sortedAreas = Object.keys(rects).map(function (key) {
	      return _extends({
	        key: key
	      }, rects[key], {
	        area: getArea(rects[key])
	      });
	    }).sort(function (a, b) {
	      return b.area - a.area;
	    });

	    var filteredAreas = sortedAreas.filter(function (_ref2) {
	      var width = _ref2.width,
	          height = _ref2.height;
	      return width >= popper.clientWidth && height >= popper.clientHeight;
	    });

	    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

	    var variation = placement.split('-')[1];

	    return computedPlacement + (variation ? '-' + variation : '');
	  }

	  /**
	   * Get offsets to the reference element
	   * @method
	   * @memberof Popper.Utils
	   * @param {Object} state
	   * @param {Element} popper - the popper element
	   * @param {Element} reference - the reference element (the popper will be relative to this)
	   * @returns {Object} An object containing the offsets which will be applied to the popper
	   */
	  function getReferenceOffsets(state, popper, reference) {
	    var commonOffsetParent = findCommonOffsetParent(popper, reference);
	    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent);
	  }

	  /**
	   * Get the outer sizes of the given element (offset size + margins)
	   * @method
	   * @memberof Popper.Utils
	   * @argument {Element} element
	   * @returns {Object} object containing width and height properties
	   */
	  function getOuterSizes(element) {
	    var styles = window.getComputedStyle(element);
	    var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
	    var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
	    var result = {
	      width: element.offsetWidth + y,
	      height: element.offsetHeight + x
	    };
	    return result;
	  }

	  /**
	   * Get the opposite placement of the given one
	   * @method
	   * @memberof Popper.Utils
	   * @argument {String} placement
	   * @returns {String} flipped placement
	   */
	  function getOppositePlacement(placement) {
	    var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
	    return placement.replace(/left|right|bottom|top/g, function (matched) {
	      return hash[matched];
	    });
	  }

	  /**
	   * Get offsets to the popper
	   * @method
	   * @memberof Popper.Utils
	   * @param {Object} position - CSS position the Popper will get applied
	   * @param {HTMLElement} popper - the popper element
	   * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
	   * @param {String} placement - one of the valid placement options
	   * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
	   */
	  function getPopperOffsets(popper, referenceOffsets, placement) {
	    placement = placement.split('-')[0];

	    // Get popper node sizes
	    var popperRect = getOuterSizes(popper);

	    // Add position, width and height to our offsets object
	    var popperOffsets = {
	      width: popperRect.width,
	      height: popperRect.height
	    };

	    // depending by the popper placement we have to compute its offsets slightly differently
	    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
	    var mainSide = isHoriz ? 'top' : 'left';
	    var secondarySide = isHoriz ? 'left' : 'top';
	    var measurement = isHoriz ? 'height' : 'width';
	    var secondaryMeasurement = !isHoriz ? 'height' : 'width';

	    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
	    if (placement === secondarySide) {
	      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
	    } else {
	      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
	    }

	    return popperOffsets;
	  }

	  /**
	   * Mimics the `find` method of Array
	   * @method
	   * @memberof Popper.Utils
	   * @argument {Array} arr
	   * @argument prop
	   * @argument value
	   * @returns index or -1
	   */
	  function find(arr, check) {
	    // use native find if supported
	    if (Array.prototype.find) {
	      return arr.find(check);
	    }

	    // use `filter` to obtain the same behavior of `find`
	    return arr.filter(check)[0];
	  }

	  /**
	   * Return the index of the matching object
	   * @method
	   * @memberof Popper.Utils
	   * @argument {Array} arr
	   * @argument prop
	   * @argument value
	   * @returns index or -1
	   */
	  function findIndex(arr, prop, value) {
	    // use native findIndex if supported
	    if (Array.prototype.findIndex) {
	      return arr.findIndex(function (cur) {
	        return cur[prop] === value;
	      });
	    }

	    // use `find` + `indexOf` if `findIndex` isn't supported
	    var match = find(arr, function (obj) {
	      return obj[prop] === value;
	    });
	    return arr.indexOf(match);
	  }

	  /**
	   * Loop trough the list of modifiers and run them in order,
	   * each of them will then edit the data object.
	   * @method
	   * @memberof Popper.Utils
	   * @param {dataObject} data
	   * @param {Array} modifiers
	   * @param {String} ends - Optional modifier name used as stopper
	   * @returns {dataObject}
	   */
	  function runModifiers(modifiers, data, ends) {
	    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

	    modifiersToRun.forEach(function (modifier) {
	      if (modifier.function) {
	        console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
	      }
	      var fn = modifier.function || modifier.fn;
	      if (modifier.enabled && isFunction(fn)) {
	        data = fn(data, modifier);
	      }
	    });

	    return data;
	  }

	  /**
	   * Updates the position of the popper, computing the new offsets and applying
	   * the new style.<br />
	   * Prefer `scheduleUpdate` over `update` because of performance reasons.
	   * @method
	   * @memberof Popper
	   */
	  function update() {
	    // if popper is destroyed, don't perform any further update
	    if (this.state.isDestroyed) {
	      return;
	    }

	    var data = {
	      instance: this,
	      styles: {},
	      attributes: {},
	      flipped: false,
	      offsets: {}
	    };

	    // compute reference element offsets
	    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference);

	    // compute auto placement, store placement inside the data object,
	    // modifiers will be able to edit `placement` if needed
	    // and refer to originalPlacement to know the original value
	    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

	    // store the computed placement inside `originalPlacement`
	    data.originalPlacement = data.placement;

	    // compute the popper offsets
	    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
	    data.offsets.popper.position = 'absolute';

	    // run the modifiers
	    data = runModifiers(this.modifiers, data);

	    // the first `update` will call `onCreate` callback
	    // the other ones will call `onUpdate` callback
	    if (!this.state.isCreated) {
	      this.state.isCreated = true;
	      this.options.onCreate(data);
	    } else {
	      this.options.onUpdate(data);
	    }
	  }

	  /**
	   * Helper used to know if the given modifier is enabled.
	   * @method
	   * @memberof Popper.Utils
	   * @returns {Boolean}
	   */
	  function isModifierEnabled(modifiers, modifierName) {
	    return modifiers.some(function (_ref) {
	      var name = _ref.name,
	          enabled = _ref.enabled;
	      return enabled && name === modifierName;
	    });
	  }

	  /**
	   * Get the prefixed supported property name
	   * @method
	   * @memberof Popper.Utils
	   * @argument {String} property (camelCase)
	   * @returns {String} prefixed property (camelCase)
	   */
	  function getSupportedPropertyName(property) {
	    var prefixes = [false, 'ms', 'webkit', 'moz', 'o'];
	    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

	    for (var i = 0; i < prefixes.length - 1; i++) {
	      var prefix = prefixes[i];
	      var toCheck = prefix ? '' + prefix + upperProp : property;
	      if (typeof window.document.body.style[toCheck] !== 'undefined') {
	        return toCheck;
	      }
	    }
	    return null;
	  }

	  /**
	   * Destroy the popper
	   * @method
	   * @memberof Popper
	   */
	  function destroy() {
	    this.state.isDestroyed = true;

	    // touch DOM only if `applyStyle` modifier is enabled
	    if (isModifierEnabled(this.modifiers, 'applyStyle')) {
	      this.popper.removeAttribute('x-placement');
	      this.popper.style.left = '';
	      this.popper.style.position = '';
	      this.popper.style.top = '';
	      this.popper.style[getSupportedPropertyName('transform')] = '';
	    }

	    this.disableEventListeners();

	    // remove the popper if user explicity asked for the deletion on destroy
	    // do not use `remove` because IE11 doesn't support it
	    if (this.options.removeOnDestroy) {
	      this.popper.parentNode.removeChild(this.popper);
	    }
	    return this;
	  }

	  function attachToScrollParents(scrollParent, event, callback, scrollParents) {
	    var isBody = scrollParent.nodeName === 'BODY';
	    var target = isBody ? window : scrollParent;
	    target.addEventListener(event, callback, { passive: true });

	    if (!isBody) {
	      attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
	    }
	    scrollParents.push(target);
	  }

	  /**
	   * Setup needed event listeners used to update the popper position
	   * @method
	   * @memberof Popper.Utils
	   * @private
	   */
	  function setupEventListeners(reference, options, state, updateBound) {
	    // Resize event listener on window
	    state.updateBound = updateBound;
	    window.addEventListener('resize', state.updateBound, { passive: true });

	    // Scroll event listener on scroll parents
	    var scrollElement = getScrollParent(reference);
	    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
	    state.scrollElement = scrollElement;
	    state.eventsEnabled = true;

	    return state;
	  }

	  /**
	   * It will add resize/scroll events and start recalculating
	   * position of the popper element when they are triggered.
	   * @method
	   * @memberof Popper
	   */
	  function enableEventListeners() {
	    if (!this.state.eventsEnabled) {
	      this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
	    }
	  }

	  /**
	   * Remove event listeners used to update the popper position
	   * @method
	   * @memberof Popper.Utils
	   * @private
	   */
	  function removeEventListeners(reference, state) {
	    // Remove resize event listener on window
	    window.removeEventListener('resize', state.updateBound);

	    // Remove scroll event listener on scroll parents
	    state.scrollParents.forEach(function (target) {
	      target.removeEventListener('scroll', state.updateBound);
	    });

	    // Reset state
	    state.updateBound = null;
	    state.scrollParents = [];
	    state.scrollElement = null;
	    state.eventsEnabled = false;
	    return state;
	  }

	  /**
	   * It will remove resize/scroll events and won't recalculate popper position
	   * when they are triggered. It also won't trigger onUpdate callback anymore,
	   * unless you call `update` method manually.
	   * @method
	   * @memberof Popper
	   */
	  function disableEventListeners() {
	    if (this.state.eventsEnabled) {
	      window.cancelAnimationFrame(this.scheduleUpdate);
	      this.state = removeEventListeners(this.reference, this.state);
	    }
	  }

	  /**
	   * Set the attributes to the given popper
	   * @method
	   * @memberof Popper.Utils
	   * @argument {Element} element - Element to apply the attributes to
	   * @argument {Object} styles
	   * Object with a list of properties and values which will be applied to the element
	   */
	  function setAttributes(element, attributes) {
	    Object.keys(attributes).forEach(function (prop) {
	      var value = attributes[prop];
	      if (value !== false) {
	        element.setAttribute(prop, attributes[prop]);
	      } else {
	        element.removeAttribute(prop);
	      }
	    });
	  }

	  /**
	   * @function
	   * @memberof Modifiers
	   * @argument {Object} data - The data object generated by `update` method
	   * @argument {Object} data.styles - List of style properties - values to apply to popper element
	   * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
	   * @argument {Object} options - Modifiers configuration and options
	   * @returns {Object} The same data object
	   */
	  function applyStyle(data, options) {
	    // apply the final offsets to the popper
	    // NOTE: 1 DOM access here
	    var styles = {
	      position: data.offsets.popper.position
	    };

	    var attributes = {
	      'x-placement': data.placement
	    };

	    // round top and left to avoid blurry text
	    var left = Math.round(data.offsets.popper.left);
	    var top = Math.round(data.offsets.popper.top);

	    // if gpuAcceleration is set to true and transform is supported,
	    //  we use `translate3d` to apply the position to the popper we
	    // automatically use the supported prefixed version if needed
	    var prefixedProperty = getSupportedPropertyName('transform');
	    if (options.gpuAcceleration && prefixedProperty) {
	      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
	      styles.top = 0;
	      styles.left = 0;
	      styles.willChange = 'transform';
	    } else {
	      // othwerise, we use the standard `left` and `top` properties
	      styles.left = left;
	      styles.top = top;
	      styles.willChange = 'top, left';
	    }

	    // any property present in `data.styles` will be applied to the popper,
	    // in this way we can make the 3rd party modifiers add custom styles to it
	    // Be aware, modifiers could override the properties defined in the previous
	    // lines of this modifier!
	    setStyles(data.instance.popper, _extends({}, styles, data.styles));

	    // any property present in `data.attributes` will be applied to the popper,
	    // they will be set as HTML attributes of the element
	    setAttributes(data.instance.popper, _extends({}, attributes, data.attributes));

	    // if the arrow style has been computed, apply the arrow style
	    if (data.offsets.arrow) {
	      setStyles(data.arrowElement, data.offsets.arrow);
	    }

	    return data;
	  }

	  /**
	   * Set the x-placement attribute before everything else because it could be used
	   * to add margins to the popper margins needs to be calculated to get the
	   * correct popper offsets.
	   * @method
	   * @memberof Popper.modifiers
	   * @param {HTMLElement} reference - The reference element used to position the popper
	   * @param {HTMLElement} popper - The HTML element used as popper.
	   * @param {Object} options - Popper.js options
	   */
	  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
	    // compute reference element offsets
	    var referenceOffsets = getReferenceOffsets(state, popper, reference);

	    // compute auto placement, store placement inside the data object,
	    // modifiers will be able to edit `placement` if needed
	    // and refer to originalPlacement to know the original value
	    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

	    popper.setAttribute('x-placement', placement);
	    return options;
	  }

	  /**
	   * Helper used to know if the given modifier depends from another one.<br />
	   * It checks if the needed modifier is listed and enabled.
	   * @method
	   * @memberof Popper.Utils
	   * @param {Array} modifiers - list of modifiers
	   * @param {String} requestingName - name of requesting modifier
	   * @param {String} requestedName - name of requested modifier
	   * @returns {Boolean}
	   */
	  function isModifierRequired(modifiers, requestingName, requestedName) {
	    var requesting = find(modifiers, function (_ref) {
	      var name = _ref.name;
	      return name === requestingName;
	    });

	    var isRequired = !!requesting && modifiers.some(function (modifier) {
	      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
	    });

	    if (!isRequired) {
	      var _requesting = '`' + requestingName + '`';
	      var requested = '`' + requestedName + '`';
	      console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
	    }
	    return isRequired;
	  }

	  /**
	   * @function
	   * @memberof Modifiers
	   * @argument {Object} data - The data object generated by update method
	   * @argument {Object} options - Modifiers configuration and options
	   * @returns {Object} The data object, properly modified
	   */
	  function arrow(data, options) {
	    // arrow depends on keepTogether in order to work
	    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
	      return data;
	    }

	    var arrowElement = options.element;

	    // if arrowElement is a string, suppose it's a CSS selector
	    if (typeof arrowElement === 'string') {
	      arrowElement = data.instance.popper.querySelector(arrowElement);

	      // if arrowElement is not found, don't run the modifier
	      if (!arrowElement) {
	        return data;
	      }
	    } else {
	      // if the arrowElement isn't a query selector we must check that the
	      // provided DOM node is child of its popper node
	      if (!data.instance.popper.contains(arrowElement)) {
	        console.warn('WARNING: `arrow.element` must be child of its popper element!');
	        return data;
	      }
	    }

	    var placement = data.placement.split('-')[0];
	    var popper = getClientRect(data.offsets.popper);
	    var reference = data.offsets.reference;
	    var isVertical = ['left', 'right'].indexOf(placement) !== -1;

	    var len = isVertical ? 'height' : 'width';
	    var side = isVertical ? 'top' : 'left';
	    var altSide = isVertical ? 'left' : 'top';
	    var opSide = isVertical ? 'bottom' : 'right';
	    var arrowElementSize = getOuterSizes(arrowElement)[len];

	    //
	    // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction
	    //

	    // top/left side
	    if (reference[opSide] - arrowElementSize < popper[side]) {
	      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
	    }
	    // bottom/right side
	    if (reference[side] + arrowElementSize > popper[opSide]) {
	      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
	    }

	    // compute center of the popper
	    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

	    // Compute the sideValue using the updated popper offsets
	    var sideValue = center - getClientRect(data.offsets.popper)[side];

	    // prevent arrowElement from being placed not contiguously to its popper
	    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

	    data.arrowElement = arrowElement;
	    data.offsets.arrow = {};
	    data.offsets.arrow[side] = Math.floor(sideValue);
	    data.offsets.arrow[altSide] = ''; // make sure to unset any eventual altSide value from the DOM node

	    return data;
	  }

	  /**
	   * Get the opposite placement variation of the given one
	   * @method
	   * @memberof Popper.Utils
	   * @argument {String} placement variation
	   * @returns {String} flipped placement variation
	   */
	  function getOppositeVariation(variation) {
	    if (variation === 'end') {
	      return 'start';
	    } else if (variation === 'start') {
	      return 'end';
	    }
	    return variation;
	  }

	  /**
	   * List of accepted placements to use as values of the `placement` option.<br />
	   * Valid placements are:
	   * - `auto`
	   * - `top`
	   * - `right`
	   * - `bottom`
	   * - `left`
	   *
	   * Each placement can have a variation from this list:
	   * - `-start`
	   * - `-end`
	   *
	   * Variations are interpreted easily if you think of them as the left to right
	   * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
	   * is right.<br />
	   * Vertically (`left` and `right`), `start` is top and `end` is bottom.
	   *
	   * Some valid examples are:
	   * - `top-end` (on top of reference, right aligned)
	   * - `right-start` (on right of reference, top aligned)
	   * - `bottom` (on bottom, centered)
	   * - `auto-right` (on the side with more space available, alignment depends by placement)
	   *
	   * @static
	   * @type {Array}
	   * @enum {String}
	   * @readonly
	   * @method placements
	   * @memberof Popper
	   */
	  var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

	  // Get rid of `auto` `auto-start` and `auto-end`
	  var validPlacements = placements.slice(3);

	  /**
	   * Given an initial placement, returns all the subsequent placements
	   * clockwise (or counter-clockwise).
	   *
	   * @method
	   * @memberof Popper.Utils
	   * @argument {String} placement - A valid placement (it accepts variations)
	   * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
	   * @returns {Array} placements including their variations
	   */
	  function clockwise(placement) {
	    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	    var index = validPlacements.indexOf(placement);
	    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
	    return counter ? arr.reverse() : arr;
	  }

	  var BEHAVIORS = {
	    FLIP: 'flip',
	    CLOCKWISE: 'clockwise',
	    COUNTERCLOCKWISE: 'counterclockwise'
	  };

	  /**
	   * @function
	   * @memberof Modifiers
	   * @argument {Object} data - The data object generated by update method
	   * @argument {Object} options - Modifiers configuration and options
	   * @returns {Object} The data object, properly modified
	   */
	  function flip(data, options) {
	    // if `inner` modifier is enabled, we can't use the `flip` modifier
	    if (isModifierEnabled(data.instance.modifiers, 'inner')) {
	      return data;
	    }

	    if (data.flipped && data.placement === data.originalPlacement) {
	      // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
	      return data;
	    }

	    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement);

	    var placement = data.placement.split('-')[0];
	    var placementOpposite = getOppositePlacement(placement);
	    var variation = data.placement.split('-')[1] || '';

	    var flipOrder = [];

	    switch (options.behavior) {
	      case BEHAVIORS.FLIP:
	        flipOrder = [placement, placementOpposite];
	        break;
	      case BEHAVIORS.CLOCKWISE:
	        flipOrder = clockwise(placement);
	        break;
	      case BEHAVIORS.COUNTERCLOCKWISE:
	        flipOrder = clockwise(placement, true);
	        break;
	      default:
	        flipOrder = options.behavior;
	    }

	    flipOrder.forEach(function (step, index) {
	      if (placement !== step || flipOrder.length === index + 1) {
	        return data;
	      }

	      placement = data.placement.split('-')[0];
	      placementOpposite = getOppositePlacement(placement);

	      var popperOffsets = getClientRect(data.offsets.popper);
	      var refOffsets = data.offsets.reference;

	      // using floor because the reference offsets may contain decimals we are not going to consider here
	      var floor = Math.floor;
	      var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

	      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
	      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
	      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
	      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

	      var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

	      // flip the variation if required
	      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
	      var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

	      if (overlapsRef || overflowsBoundaries || flippedVariation) {
	        // this boolean to detect any flip loop
	        data.flipped = true;

	        if (overlapsRef || overflowsBoundaries) {
	          placement = flipOrder[index + 1];
	        }

	        if (flippedVariation) {
	          variation = getOppositeVariation(variation);
	        }

	        data.placement = placement + (variation ? '-' + variation : '');

	        // this object contains `position`, we want to preserve it along with
	        // any additional property we may add in the future
	        data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

	        data = runModifiers(data.instance.modifiers, data, 'flip');
	      }
	    });
	    return data;
	  }

	  /**
	   * @function
	   * @memberof Modifiers
	   * @argument {Object} data - The data object generated by update method
	   * @argument {Object} options - Modifiers configuration and options
	   * @returns {Object} The data object, properly modified
	   */
	  function keepTogether(data) {
	    var popper = getClientRect(data.offsets.popper);
	    var reference = data.offsets.reference;
	    var placement = data.placement.split('-')[0];
	    var floor = Math.floor;
	    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
	    var side = isVertical ? 'right' : 'bottom';
	    var opSide = isVertical ? 'left' : 'top';
	    var measurement = isVertical ? 'width' : 'height';

	    if (popper[side] < floor(reference[opSide])) {
	      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
	    }
	    if (popper[opSide] > floor(reference[side])) {
	      data.offsets.popper[opSide] = floor(reference[side]);
	    }

	    return data;
	  }

	  /**
	   * Converts a string containing value + unit into a px value number
	   * @function
	   * @memberof {modifiers~offset}
	   * @private
	   * @argument {String} str - Value + unit string
	   * @argument {String} measurement - `height` or `width`
	   * @argument {Object} popperOffsets
	   * @argument {Object} referenceOffsets
	   * @returns {Number|String}
	   * Value in pixels, or original string if no values were extracted
	   */
	  function toValue(str, measurement, popperOffsets, referenceOffsets) {
	    // separate value from unit
	    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
	    var value = +split[1];
	    var unit = split[2];

	    // If it's not a number it's an operator, I guess
	    if (!value) {
	      return str;
	    }

	    if (unit.indexOf('%') === 0) {
	      var element = void 0;
	      switch (unit) {
	        case '%p':
	          element = popperOffsets;
	          break;
	        case '%':
	        case '%r':
	        default:
	          element = referenceOffsets;
	      }

	      var rect = getClientRect(element);
	      return rect[measurement] / 100 * value;
	    } else if (unit === 'vh' || unit === 'vw') {
	      // if is a vh or vw, we calculate the size based on the viewport
	      var size = void 0;
	      if (unit === 'vh') {
	        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
	      } else {
	        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
	      }
	      return size / 100 * value;
	    } else {
	      // if is an explicit pixel unit, we get rid of the unit and keep the value
	      // if is an implicit unit, it's px, and we return just the value
	      return value;
	    }
	  }

	  /**
	   * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
	   * @function
	   * @memberof {modifiers~offset}
	   * @private
	   * @argument {String} offset
	   * @argument {Object} popperOffsets
	   * @argument {Object} referenceOffsets
	   * @argument {String} basePlacement
	   * @returns {Array} a two cells array with x and y offsets in numbers
	   */
	  function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
	    var offsets = [0, 0];

	    // Use height if placement is left or right and index is 0 otherwise use width
	    // in this way the first offset will use an axis and the second one
	    // will use the other one
	    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

	    // Split the offset string to obtain a list of values and operands
	    // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
	    var fragments = offset.split(/(\+|\-)/).map(function (frag) {
	      return frag.trim();
	    });

	    // Detect if the offset string contains a pair of values or a single one
	    // they could be separated by comma or space
	    var divider = fragments.indexOf(find(fragments, function (frag) {
	      return frag.search(/,|\s/) !== -1;
	    }));

	    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
	      console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
	    }

	    // If divider is found, we divide the list of values and operands to divide
	    // them by ofset X and Y.
	    var splitRegex = /\s*,\s*|\s+/;
	    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

	    // Convert the values with units to absolute pixels to allow our computations
	    ops = ops.map(function (op, index) {
	      // Most of the units rely on the orientation of the popper
	      var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
	      var mergeWithPrevious = false;
	      return op
	      // This aggregates any `+` or `-` sign that aren't considered operators
	      // e.g.: 10 + +5 => [10, +, +5]
	      .reduce(function (a, b) {
	        if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
	          a[a.length - 1] = b;
	          mergeWithPrevious = true;
	          return a;
	        } else if (mergeWithPrevious) {
	          a[a.length - 1] += b;
	          mergeWithPrevious = false;
	          return a;
	        } else {
	          return a.concat(b);
	        }
	      }, [])
	      // Here we convert the string values into number values (in px)
	      .map(function (str) {
	        return toValue(str, measurement, popperOffsets, referenceOffsets);
	      });
	    });

	    // Loop trough the offsets arrays and execute the operations
	    ops.forEach(function (op, index) {
	      op.forEach(function (frag, index2) {
	        if (isNumeric(frag)) {
	          offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
	        }
	      });
	    });
	    return offsets;
	  }

	  /**
	   * @function
	   * @memberof Modifiers
	   * @argument {Object} data - The data object generated by update method
	   * @argument {Object} options - Modifiers configuration and options
	   * @argument {Number|String} options.offset=0
	   * The offset value as described in the modifier description
	   * @returns {Object} The data object, properly modified
	   */
	  function offset(data, _ref) {
	    var offset = _ref.offset;
	    var placement = data.placement,
	        _data$offsets = data.offsets,
	        popper = _data$offsets.popper,
	        reference = _data$offsets.reference;

	    var basePlacement = placement.split('-')[0];

	    var offsets = void 0;
	    if (isNumeric(+offset)) {
	      offsets = [+offset, 0];
	    } else {
	      offsets = parseOffset(offset, popper, reference, basePlacement);
	    }

	    if (basePlacement === 'left') {
	      popper.top += offsets[0];
	      popper.left -= offsets[1];
	    } else if (basePlacement === 'right') {
	      popper.top += offsets[0];
	      popper.left += offsets[1];
	    } else if (basePlacement === 'top') {
	      popper.left += offsets[0];
	      popper.top -= offsets[1];
	    } else if (basePlacement === 'bottom') {
	      popper.left += offsets[0];
	      popper.top += offsets[1];
	    }

	    data.popper = popper;
	    return data;
	  }

	  /**
	   * @function
	   * @memberof Modifiers
	   * @argument {Object} data - The data object generated by `update` method
	   * @argument {Object} options - Modifiers configuration and options
	   * @returns {Object} The data object, properly modified
	   */
	  function preventOverflow(data, options) {
	    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
	    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement);
	    options.boundaries = boundaries;

	    var order = options.priority;
	    var popper = getClientRect(data.offsets.popper);

	    var check = {
	      primary: function primary(placement) {
	        var value = popper[placement];
	        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
	          value = Math.max(popper[placement], boundaries[placement]);
	        }
	        return defineProperty({}, placement, value);
	      },
	      secondary: function secondary(placement) {
	        var mainSide = placement === 'right' ? 'left' : 'top';
	        var value = popper[mainSide];
	        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
	          value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
	        }
	        return defineProperty({}, mainSide, value);
	      }
	    };

	    order.forEach(function (placement) {
	      var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
	      popper = _extends({}, popper, check[side](placement));
	    });

	    data.offsets.popper = popper;

	    return data;
	  }

	  /**
	   * @function
	   * @memberof Modifiers
	   * @argument {Object} data - The data object generated by `update` method
	   * @argument {Object} options - Modifiers configuration and options
	   * @returns {Object} The data object, properly modified
	   */
	  function shift(data) {
	    var placement = data.placement;
	    var basePlacement = placement.split('-')[0];
	    var shiftvariation = placement.split('-')[1];

	    // if shift shiftvariation is specified, run the modifier
	    if (shiftvariation) {
	      var reference = data.offsets.reference;
	      var popper = getClientRect(data.offsets.popper);
	      var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
	      var side = isVertical ? 'left' : 'top';
	      var measurement = isVertical ? 'width' : 'height';

	      var shiftOffsets = {
	        start: defineProperty({}, side, reference[side]),
	        end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
	      };

	      data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
	    }

	    return data;
	  }

	  /**
	   * @function
	   * @memberof Modifiers
	   * @argument {Object} data - The data object generated by update method
	   * @argument {Object} options - Modifiers configuration and options
	   * @returns {Object} The data object, properly modified
	   */
	  function hide(data) {
	    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
	      return data;
	    }

	    var refRect = data.offsets.reference;
	    var bound = find(data.instance.modifiers, function (modifier) {
	      return modifier.name === 'preventOverflow';
	    }).boundaries;

	    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
	      // Avoid unnecessary DOM access if visibility hasn't changed
	      if (data.hide === true) {
	        return data;
	      }

	      data.hide = true;
	      data.attributes['x-out-of-boundaries'] = '';
	    } else {
	      // Avoid unnecessary DOM access if visibility hasn't changed
	      if (data.hide === false) {
	        return data;
	      }

	      data.hide = false;
	      data.attributes['x-out-of-boundaries'] = false;
	    }

	    return data;
	  }

	  /**
	   * @function
	   * @memberof Modifiers
	   * @argument {Object} data - The data object generated by `update` method
	   * @argument {Object} options - Modifiers configuration and options
	   * @returns {Object} The data object, properly modified
	   */
	  function inner(data) {
	    var placement = data.placement;
	    var basePlacement = placement.split('-')[0];
	    var popper = getClientRect(data.offsets.popper);
	    var reference = getClientRect(data.offsets.reference);
	    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

	    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

	    popper[isHoriz ? 'left' : 'top'] = reference[placement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

	    data.placement = getOppositePlacement(placement);
	    data.offsets.popper = getClientRect(popper);

	    return data;
	  }

	  /**
	   * Modifier function, each modifier can have a function of this type assigned
	   * to its `fn` property.<br />
	   * These functions will be called on each update, this means that you must
	   * make sure they are performant enough to avoid performance bottlenecks.
	   *
	   * @function ModifierFn
	   * @argument {dataObject} data - The data object generated by `update` method
	   * @argument {Object} options - Modifiers configuration and options
	   * @returns {dataObject} The data object, properly modified
	   */

	  /**
	   * Modifiers are plugins used to alter the behavior of your poppers.<br />
	   * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
	   * needed by the library.
	   *
	   * Usually you don't want to override the `order`, `fn` and `onLoad` props.
	   * All the other properties are configurations that could be tweaked.
	   * @namespace modifiers
	   */
	  var modifiers = {
	    /**
	     * Modifier used to shift the popper on the start or end of its reference
	     * element.<br />
	     * It will read the variation of the `placement` property.<br />
	     * It can be one either `-end` or `-start`.
	     * @memberof modifiers
	     * @inner
	     */
	    shift: {
	      /** @prop {number} order=100 - Index used to define the order of execution */
	      order: 100,
	      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	      enabled: true,
	      /** @prop {ModifierFn} */
	      fn: shift
	    },

	    /**
	     * The `offset` modifier can shift your popper on both its axis.
	     *
	     * It accepts the following units:
	     * - `px` or unitless, interpreted as pixels
	     * - `%` or `%r`, percentage relative to the length of the reference element
	     * - `%p`, percentage relative to the length of the popper element
	     * - `vw`, CSS viewport width unit
	     * - `vh`, CSS viewport height unit
	     *
	     * For length is intended the main axis relative to the placement of the popper.<br />
	     * This means that if the placement is `top` or `bottom`, the length will be the
	     * `width`. In case of `left` or `right`, it will be the height.
	     *
	     * You can provide a single value (as `Number` or `String`), or a pair of values
	     * as `String` divided by a comma or one (or more) white spaces.<br />
	     * The latter is a deprecated method because it leads to confusion and will be
	     * removed in v2.<br />
	     * Additionally, it accepts additions and subtractions between different units.
	     * Note that multiplications and divisions aren't supported.
	     *
	     * Valid examples are:
	     * ```
	     * 10
	     * '10%'
	     * '10, 10'
	     * '10%, 10'
	     * '10 + 10%'
	     * '10 - 5vh + 3%'
	     * '-10px + 5vh, 5px - 6%'
	     * ```
	     *
	     * @memberof modifiers
	     * @inner
	     */
	    offset: {
	      /** @prop {number} order=200 - Index used to define the order of execution */
	      order: 200,
	      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	      enabled: true,
	      /** @prop {ModifierFn} */
	      fn: offset,
	      /** @prop {Number|String} offset=0
	       * The offset value as described in the modifier description
	       */
	      offset: 0
	    },

	    /**
	     * Modifier used to prevent the popper from being positioned outside the boundary.
	     *
	     * An scenario exists where the reference itself is not within the boundaries.<br />
	     * We can say it has "escaped the boundaries" — or just "escaped".<br />
	     * In this case we need to decide whether the popper should either:
	     *
	     * - detach from the reference and remain "trapped" in the boundaries, or
	     * - if it should ignore the boundary and "escape with its reference"
	     *
	     * When `escapeWithReference` is set to`true` and reference is completely
	     * outside its boundaries, the popper will overflow (or completely leave)
	     * the boundaries in order to remain attached to the edge of the reference.
	     *
	     * @memberof modifiers
	     * @inner
	     */
	    preventOverflow: {
	      /** @prop {number} order=300 - Index used to define the order of execution */
	      order: 300,
	      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	      enabled: true,
	      /** @prop {ModifierFn} */
	      fn: preventOverflow,
	      /**
	       * @prop {Array} priority=['left', 'right', 'top', 'bottom']
	       * Popper will try to prevent overflow following these priorities by default,
	       * then, it could overflow on the left and on top of the `boundariesElement`
	       */
	      priority: ['left', 'right', 'top', 'bottom'],
	      /**
	       * @prop {number} padding=5
	       * Amount of pixel used to define a minimum distance between the boundaries
	       * and the popper this makes sure the popper has always a little padding
	       * between the edges of its container
	       */
	      padding: 5,
	      /**
	       * @prop {String|HTMLElement} boundariesElement='scrollParent'
	       * Boundaries used by the modifier, can be `scrollParent`, `window`,
	       * `viewport` or any DOM element.
	       */
	      boundariesElement: 'scrollParent'
	    },

	    /**
	     * Modifier used to make sure the reference and its popper stay near eachothers
	     * without leaving any gap between the two. Expecially useful when the arrow is
	     * enabled and you want to assure it to point to its reference element.
	     * It cares only about the first axis, you can still have poppers with margin
	     * between the popper and its reference element.
	     * @memberof modifiers
	     * @inner
	     */
	    keepTogether: {
	      /** @prop {number} order=400 - Index used to define the order of execution */
	      order: 400,
	      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	      enabled: true,
	      /** @prop {ModifierFn} */
	      fn: keepTogether
	    },

	    /**
	     * This modifier is used to move the `arrowElement` of the popper to make
	     * sure it is positioned between the reference element and its popper element.
	     * It will read the outer size of the `arrowElement` node to detect how many
	     * pixels of conjuction are needed.
	     *
	     * It has no effect if no `arrowElement` is provided.
	     * @memberof modifiers
	     * @inner
	     */
	    arrow: {
	      /** @prop {number} order=500 - Index used to define the order of execution */
	      order: 500,
	      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	      enabled: true,
	      /** @prop {ModifierFn} */
	      fn: arrow,
	      /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
	      element: '[x-arrow]'
	    },

	    /**
	     * Modifier used to flip the popper's placement when it starts to overlap its
	     * reference element.
	     *
	     * Requires the `preventOverflow` modifier before it in order to work.
	     *
	     * **NOTE:** this modifier will interrupt the current update cycle and will
	     * restart it if it detects the need to flip the placement.
	     * @memberof modifiers
	     * @inner
	     */
	    flip: {
	      /** @prop {number} order=600 - Index used to define the order of execution */
	      order: 600,
	      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	      enabled: true,
	      /** @prop {ModifierFn} */
	      fn: flip,
	      /**
	       * @prop {String|Array} behavior='flip'
	       * The behavior used to change the popper's placement. It can be one of
	       * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
	       * placements (with optional variations).
	       */
	      behavior: 'flip',
	      /**
	       * @prop {number} padding=5
	       * The popper will flip if it hits the edges of the `boundariesElement`
	       */
	      padding: 5,
	      /**
	       * @prop {String|HTMLElement} boundariesElement='viewport'
	       * The element which will define the boundaries of the popper position,
	       * the popper will never be placed outside of the defined boundaries
	       * (except if keepTogether is enabled)
	       */
	      boundariesElement: 'viewport'
	    },

	    /**
	     * Modifier used to make the popper flow toward the inner of the reference element.
	     * By default, when this modifier is disabled, the popper will be placed outside
	     * the reference element.
	     * @memberof modifiers
	     * @inner
	     */
	    inner: {
	      /** @prop {number} order=700 - Index used to define the order of execution */
	      order: 700,
	      /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
	      enabled: false,
	      /** @prop {ModifierFn} */
	      fn: inner
	    },

	    /**
	     * Modifier used to hide the popper when its reference element is outside of the
	     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
	     * be used to hide with a CSS selector the popper when its reference is
	     * out of boundaries.
	     *
	     * Requires the `preventOverflow` modifier before it in order to work.
	     * @memberof modifiers
	     * @inner
	     */
	    hide: {
	      /** @prop {number} order=800 - Index used to define the order of execution */
	      order: 800,
	      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	      enabled: true,
	      /** @prop {ModifierFn} */
	      fn: hide
	    },

	    /**
	     * Applies the computed styles to the popper element.
	     *
	     * All the DOM manipulations are limited to this modifier. This is useful in case
	     * you want to integrate Popper.js inside a framework or view library and you
	     * want to delegate all the DOM manipulations to it.
	     *
	     * Just disable this modifier and define you own to achieve the desired effect.
	     *
	     * @memberof modifiers
	     * @inner
	     */
	    applyStyle: {
	      /** @prop {number} order=900 - Index used to define the order of execution */
	      order: 900,
	      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	      enabled: true,
	      /** @prop {ModifierFn} */
	      fn: applyStyle,
	      /** @prop {Function} */
	      onLoad: applyStyleOnLoad,
	      /**
	       * @prop {Boolean} gpuAcceleration=true
	       * If true, it uses the CSS 3d transformation to position the popper.
	       * Otherwise, it will use the `top` and `left` properties.
	       */
	      gpuAcceleration: true
	    }
	  };

	  /**
	   * The `dataObject` is an object containing all the informations used by Popper.js
	   * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
	   * @name dataObject
	   * @property {Object} data.instance The Popper.js instance
	   * @property {String} data.placement Placement applied to popper
	   * @property {String} data.originalPlacement Placement originally defined on init
	   * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
	   * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
	   * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
	   * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)
	   * @property {Object} data.boundaries Offsets of the popper boundaries
	   * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
	   * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
	   * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
	   * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
	   */

	  /**
	   * Default options provided to Popper.js constructor.<br />
	   * These can be overriden using the `options` argument of Popper.js.<br />
	   * To override an option, simply pass as 3rd argument an object with the same
	   * structure of this object, example:
	   * ```
	   * new Popper(ref, pop, {
	   *   modifiers: {
	   *     preventOverflow: { enabled: false }
	   *   }
	   * })
	   * ```
	   * @type {Object}
	   * @static
	   * @memberof Popper
	   */
	  var DEFAULTS = {
	    /**
	     * Popper's placement
	     * @prop {Popper.placements} placement='bottom'
	     */
	    placement: 'bottom',

	    /**
	     * Whether events (resize, scroll) are initially enabled
	     * @prop {Boolean} eventsEnabled=true
	     */
	    eventsEnabled: true,

	    /**
	     * Set to true if you want to automatically remove the popper when
	     * you call the `destroy` method.
	     * @prop {Boolean} removeOnDestroy=false
	     */
	    removeOnDestroy: false,

	    /**
	     * Callback called when the popper is created.<br />
	     * By default, is set to no-op.<br />
	     * Access Popper.js instance with `data.instance`.
	     * @prop {onCreate}
	     */
	    onCreate: function onCreate() {},

	    /**
	     * Callback called when the popper is updated, this callback is not called
	     * on the initialization/creation of the popper, but only on subsequent
	     * updates.<br />
	     * By default, is set to no-op.<br />
	     * Access Popper.js instance with `data.instance`.
	     * @prop {onUpdate}
	     */
	    onUpdate: function onUpdate() {},

	    /**
	     * List of modifiers used to modify the offsets before they are applied to the popper.
	     * They provide most of the functionalities of Popper.js
	     * @prop {modifiers}
	     */
	    modifiers: modifiers
	  };

	  /**
	   * @callback onCreate
	   * @param {dataObject} data
	   */

	  /**
	   * @callback onUpdate
	   * @param {dataObject} data
	   */

	  // Utils
	  // Methods
	  var Popper = function () {
	    /**
	     * Create a new Popper.js instance
	     * @class Popper
	     * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
	     * @param {HTMLElement} popper - The HTML element used as popper.
	     * @param {Object} options - Your custom options to override the ones defined in [DEFAULTS](#defaults)
	     * @return {Object} instance - The generated Popper.js instance
	     */
	    function Popper(reference, popper) {
	      var _this = this;

	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	      classCallCheck(this, Popper);

	      this.scheduleUpdate = function () {
	        return requestAnimationFrame(_this.update);
	      };

	      // make update() debounced, so that it only runs at most once-per-tick
	      this.update = debounce(this.update.bind(this));

	      // with {} we create a new object with the options inside it
	      this.options = _extends({}, Popper.Defaults, options);

	      // init state
	      this.state = {
	        isDestroyed: false,
	        isCreated: false,
	        scrollParents: []
	      };

	      // get reference and popper elements (allow jQuery wrappers)
	      this.reference = reference.jquery ? reference[0] : reference;
	      this.popper = popper.jquery ? popper[0] : popper;

	      // make sure to apply the popper position before any computation
	      setStyles(this.popper, { position: 'absolute' });

	      // Deep merge modifiers options
	      this.options.modifiers = {};
	      Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
	        _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
	      });

	      // Refactoring modifiers' list (Object => Array)
	      this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
	        return _extends({
	          name: name
	        }, _this.options.modifiers[name]);
	      })
	      // sort the modifiers by order
	      .sort(function (a, b) {
	        return a.order - b.order;
	      });

	      // modifiers have the ability to execute arbitrary code when Popper.js get inited
	      // such code is executed in the same order of its modifier
	      // they could add new properties to their options configuration
	      // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
	      this.modifiers.forEach(function (modifierOptions) {
	        if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
	          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
	        }
	      });

	      // fire the first update to position the popper in the right place
	      this.update();

	      var eventsEnabled = this.options.eventsEnabled;
	      if (eventsEnabled) {
	        // setup event listeners, they will take care of update the position in specific situations
	        this.enableEventListeners();
	      }

	      this.state.eventsEnabled = eventsEnabled;
	    }

	    // We can't use class properties because they don't get listed in the
	    // class prototype and break stuff like Sinon stubs


	    createClass(Popper, [{
	      key: 'update',
	      value: function update$$1() {
	        return update.call(this);
	      }
	    }, {
	      key: 'destroy',
	      value: function destroy$$1() {
	        return destroy.call(this);
	      }
	    }, {
	      key: 'enableEventListeners',
	      value: function enableEventListeners$$1() {
	        return enableEventListeners.call(this);
	      }
	    }, {
	      key: 'disableEventListeners',
	      value: function disableEventListeners$$1() {
	        return disableEventListeners.call(this);
	      }

	      /**
	       * Schedule an update, it will run on the next UI update available
	       * @method scheduleUpdate
	       * @memberof Popper
	       */

	      /**
	       * Collection of utilities useful when writing custom modifiers.
	       * Starting from version 1.7, this method is available only if you
	       * include `popper-utils.js` before `popper.js`.
	       *
	       * **DEPRECATION**: This way to access PopperUtils is deprecated
	       * and will be removed in v2! Use the PopperUtils module directly instead.
	       * @static
	       * @type {Object}
	       * @deprecated since version 1.8
	       * @member Utils
	       * @memberof Popper
	       */

	    }]);
	    return Popper;
	  }();

	  /**
	   * The `referenceObject` is an object that provides an interface compatible with Popper.js
	   * and lets you use it as replacement of a real DOM node.<br />
	   * You can use this method to position a popper relatively to a set of coordinates
	   * in case you don't have a DOM node to use as reference.
	   *
	   * ```
	   * new Popper(referenceObject, popperNode);
	   * ```
	   *
	   * NB: This feature isn't supported in Internet Explorer 10
	   * @name referenceObject
	   * @property {Function} data.getBoundingClientRect
	   * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
	   * @property {number} data.clientWidth
	   * An ES6 getter that will return the width of the virtual reference element.
	   * @property {number} data.clientHeight
	   * An ES6 getter that will return the height of the virtual reference element.
	   */

	  Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
	  Popper.placements = placements;
	  Popper.Defaults = DEFAULTS;

	  return Popper;
	});
	//# sourceMappingURL=popper.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _jquery = __webpack_require__(3);

	var _jquery2 = _interopRequireDefault(_jquery);

	var _emitter = __webpack_require__(5);

	var _emitter2 = _interopRequireDefault(_emitter);

	var _defaults = __webpack_require__(21);

	var _defaults2 = _interopRequireDefault(_defaults);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var NAME = 'validation';
	var DEFAULTS = {
	  events: 'blur',
	  selector: '[data-required]'
	};

	var Validation = function () {
	  function Validation(element, options) {
	    _classCallCheck(this, Validation);

	    this.$element = (0, _jquery2.default)(element);
	    this.options = _jquery2.default.extend({}, DEFAULTS, options || {});
	  }

	  _createClass(Validation, [{
	    key: 'init',
	    value: function init() {
	      this._fields = this.$element.find(this.options.selector);

	      this.bindListeners();

	      return this;
	    }
	  }, {
	    key: 'bindListeners',
	    value: function bindListeners() {
	      var _this = this;

	      this.handler = function (e) {
	        _this.validate(e.target);
	      };

	      this.$element.off(this.options.events, this.options.selector, this.handler);
	      this.$element.on(this.options.events, this.options.selector, this.handler);
	    }
	  }, {
	    key: 'setPristine',
	    value: function setPristine(field) {
	      _emitter2.default.emit('validation:pristine', field);
	    }
	  }, {
	    key: 'validate',
	    value: function validate(field) {
	      var _this2 = this;

	      var rules = field.getAttribute('data-validate');

	      if (!rules) {
	        return;
	      }

	      rules = rules.split(' ').reduce(function (errors, rule) {
	        if (!_this2.rules[rule].call(_this2, field, _this2.$element)) {
	          errors.push(rule);
	        }

	        return errors;
	      }, []);

	      _emitter2.default.emit('validation:' + (!rules.length ? 'success' : 'error'), field, rules);

	      return !rules.length;
	    }
	  }, {
	    key: 'validateAll',
	    value: function validateAll() {
	      return Array.prototype.map.call(this.getFilteredInputs(), this.validate, this).every(function (validation) {
	        return validation;
	      });
	    }
	  }, {
	    key: 'getFilteredInputs',
	    value: function getFilteredInputs() {
	      return Array.prototype.filter.call(this.$element.find(this.options.selector), this.getValidInputs);
	    }
	  }, {
	    key: 'getValidInputs',
	    value: function getValidInputs(input) {
	      return input.hasAttribute('data-validate');
	    }
	  }]);

	  return Validation;
	}();

	Validation.prototype.rules = _defaults2.default;

	/* istanbul ignore next */
	_jquery2.default.fn[NAME] = function (options) {
	  options = options || {};

	  return this.each(function () {
	    if (!_jquery2.default.data(this, NAME)) {
	      _jquery2.default.data(this, NAME, new Validation(this, options).init());
	    }
	  });
	};

	exports.default = Validation;

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _required = __webpack_require__(22);

	var _required2 = _interopRequireDefault(_required);

	var _confirm = __webpack_require__(23);

	var _confirm2 = _interopRequireDefault(_confirm);

	var _minlength = __webpack_require__(24);

	var _minlength2 = _interopRequireDefault(_minlength);

	var _maxlength = __webpack_require__(25);

	var _maxlength2 = _interopRequireDefault(_maxlength);

	var _email = __webpack_require__(26);

	var _email2 = _interopRequireDefault(_email);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  required: _required2.default,
	  confirm: _confirm2.default,
	  minlength: _minlength2.default,
	  maxlength: _maxlength2.default,
	  email: _email2.default
		};

/***/ },
/* 22 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (field, $form) {
	  if (field.type === 'checkbox') {
	    return field.checked;
	  }

	  if (field.type === 'radio') {
	    return $form.find('[name="' + field.name + '"]:checked').length;
	  }

	  return !!field.value.trim();
	};

/***/ },
/* 23 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (field, $form) {
	  return field.value === $form.find('[name="' + field.getAttribute('data-confirm') + '"]').val();
		};

/***/ },
/* 24 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (field) {
	  return field.value.length >= field.getAttribute('data-minlength');
		};

/***/ },
/* 25 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (field) {
	  return field.value.length <= field.getAttribute('maxlength');
		};

/***/ },
/* 26 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (field) {
	  return (/^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(field.value)
	  );
		};

/***/ }
/******/ ]);
//# sourceMappingURL=garden.min.js.map